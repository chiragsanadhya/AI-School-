1. main.py

Purpose: The entry point of your FastAPI application.
What it does: It creates the FastAPI app object, includes routes, sets middleware, handles app startup/shutdown events, etc.
Connection: Imports and mounts all the API routes defined under api/v1/routes.


2. api/

Purpose: Organizes your API endpoints.
Structure:
__init__.py: Makes it a package.
v1/: Versioning layer to allow backward compatibility.
routes/: Contains all individual route files grouped by feature (auth, rag, test, etc.).
Each file in routes/ defines the URL endpoints and connects to services or business logic.


3. core/

Purpose: Handles app-wide configurations and security logic.
Files:
config.py: App settings (e.g., environment variables, DB URL, secrets).
auth.py: Auth-related utilities (e.g., token creation).
security.py: Hashing, JWT, OAuth logic.
Connection: Used across the app where secure access or config data is needed.


4. services/

Purpose: Business logic layerâ€”decouples routes from logic.
What they do:
Each file handles a service domain (e.g., ml_service.py deals with ML-related tasks).
Routes import functions from services to execute the actual work.
Example: rag_service.py contains core logic for RAG, which routes/rag.py exposes via endpoints.


5. ml/

Purpose: Contains ML-specific implementations and modules.
Files:
embeddings.py, rag.py, etc., contain actual model logic, inference code, vector generation, etc.
Connection: These files are used inside services/ml_service.py or directly by APIs if needed.


6. schemas/

Purpose: Pydantic models for data validation and serialization.
What they define: Request and response models (like UserCreate, UserOut, etc.).
Connection: Imported into routes and services to enforce input/output formats.


7. __pycache__/

Purpose: Auto-generated bytecode by Python for performance.
You can ignore or exclude this from version control (e.g., via .gitignore).



Flow Summary (Example: RAG endpoint):
- Client hits an endpoint, e.g., POST /api/v1/rag/generate.
- routes/rag.py handles the request, validating input using a schema (if any).
- It calls a function from services/rag_service.py, which contains business logic.
- The service internally uses ml/rag.py to perform vector search or generation.
- Any configuration or secrets it needs comes from core/config.py.
